import os
import time
from pathlib import Path
from typing import Dict

from .api import ApiClient
from .files import FileManager
from .gui import GuiController
from .clipboard import ClipboardManager
from .logging_setup import LoggerFactory
from .lock import InstanceLock


class RobustNotepadBot:
    def __init__(self,
                 api_url: str,
                 api_timeout: int,
                 output_dir: Path,
                 conflict_action: str,
                 typing_interval: float,
                 waits: Dict[str, float],
                 log_file: str,
                 log_level: str = 'INFO'):
        self.logger = LoggerFactory.create_logger('tjm.robust', log_file, log_level)
        self.api = ApiClient(api_url, api_timeout, self.logger)
        self.files = FileManager(output_dir, conflict_action, self.logger)
        self.gui = GuiController(self.logger, typing_interval, waits)
        self.clipboard = ClipboardManager(self.logger)
        self.lock = InstanceLock(output_dir / '.run.lock', self.logger)

    def run(self, limit: int, prefix: str, extension: str) -> Dict[str, int]:
        stats = {'total_posts': 0, 'successful_posts': 0, 'failed_posts': 0}
        if not self.lock.acquire():
            return stats
        try:
            if not self.files.ensure_output_dir():
                self.logger.error('Output directory not writable')
                return stats
            posts = self.api.fetch_posts(limit)
            if not posts:
                return stats
            stats['total_posts'] = len(posts)

            is_windows = os.name == 'nt'
            if is_windows:
                if not self.gui.launch_or_focus_notepad():
                    self.logger.error('GUI automation unavailable; degrading to direct writes')
                    is_windows = False

            for idx, post in enumerate(posts, 1):
                post_id = post.get('id', idx)
                raw_name = f"{prefix} {post_id}"
                filename = self.files.sanitize_filename(raw_name, extension)
                target = self.files.resolve_conflict(self.files.output_dir / filename)
                if target is None:
                    stats['successful_posts'] += 1
                    continue
                content = self._format_post(post)

                if not self.files.has_enough_space(len(content.encode('utf-8', errors='replace')) + 1024):
                    self.logger.error('Insufficient disk space; aborting remaining tasks')
                    break

                ok: bool
                if is_windows:
                    ok = self._process_via_gui(target, content)
                else:
                    ok = self.files.write_text(target, content)

                if ok and self._verify_file_integrity(target, content):
                    stats['successful_posts'] += 1
                else:
                    stats['failed_posts'] += 1
                time.sleep(0.3)

            try:
                self.gui.close_notepad()
            except Exception:
                pass
            return stats
        finally:
            self.lock.release()

    def _process_via_gui(self, target: Path, content: str) -> bool:
        if not self.gui.replace_editor_text(content, self.clipboard):
            return False
        if not self.gui.save_via_ui(target.parent, target.name):
            self.gui.handle_unexpected_dialogs()
        if not target.exists():
            self.logger.warning('UI save did not create file; attempting direct write')
            return self.files.write_text(target, content)
        return True

    def _verify_file_integrity(self, path: Path, content: str) -> bool:
        def normalize_text(text: str) -> str:
            return text.replace('\r\n', '\n').replace('\r', '\n').replace('\n', os.linesep)

        expected_text = normalize_text(content)
        expected_hash = self.files.sha256_of_text(expected_text)
        try:
            with open(path, 'r', encoding='utf-8', errors='replace', newline=None) as f:
                saved_text = f.read()
        except Exception as exc:
            self.logger.warning(f"Could not read saved file for integrity check: {path.name}: {exc}")
            return False
        actual_text = normalize_text(saved_text)
        actual_hash = self.files.sha256_of_text(actual_text)
        if expected_hash != actual_hash:
            self.logger.warning(f"Hash mismatch for {path.name}")
            return False
        return True

    @staticmethod
    def _format_post(post: Dict) -> str:
        title = str(post.get('title', 'Untitled Post'))
        body = str(post.get('body', 'No content available.'))
        return (
            f"BLOG POST #{post.get('id', 'Unknown')}\n\n"
            f"{title.upper()}\n\n"
            f"{body}\n\n"
            f"---\nGenerated by TJM Automation Bot\n"
            f"Post ID: {post.get('id', 'Unknown')}\n"
            f"User ID: {post.get('userId', 'Unknown')}\n"
        )


